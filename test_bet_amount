<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests Unitaires - Gestion des Mises</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .test-container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }

        .test-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }

        .test-status {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .test-status.passed {
            background-color: #4caf50;
            color: white;
        }

        .test-status.failed {
            background-color: #f44336;
            color: white;
        }

        .test-status.running {
            background-color: #ff9800;
            color: white;
        }

        .test-details {
            margin-top: 10px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .test-step {
            margin: 5px 0;
            padding: 5px;
        }

        .test-step.success {
            color: #2e7d32;
        }

        .test-step.error {
            color: #c62828;
            font-weight: bold;
        }

        .summary {
            background: white;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            margin-top: 30px;
        }

        .summary h2 {
            color: #333;
            margin-bottom: 20px;
        }

        .summary-stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
        }

        .stat-box {
            padding: 20px;
            border-radius: 10px;
            min-width: 150px;
        }

        .stat-box.total {
            background-color: #2196f3;
            color: white;
        }

        .stat-box.passed {
            background-color: #4caf50;
            color: white;
        }

        .stat-box.failed {
            background-color: #f44336;
            color: white;
        }

        .stat-number {
            font-size: 3em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .run-button {
            background-color: #667eea;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 8px;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .run-button:hover {
            background-color: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        .run-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
    </style>
</head>
<body>
    <h1>üé∞ Tests Unitaires - Syst√®me de Gestion des Mises</h1>
    
    <button class="run-button" onclick="runAllTests()">‚ñ∂Ô∏è Lancer tous les tests</button>
    
    <div id="test-results"></div>
    
    <div class="summary" id="summary">
        <h2>üìä R√©sum√© des Tests</h2>
        <div class="summary-stats">
            <div class="stat-box total">
                <div class="stat-number" id="total-tests">0</div>
                <div class="stat-label">Total</div>
            </div>
            <div class="stat-box passed">
                <div class="stat-number" id="passed-tests">0</div>
                <div class="stat-label">R√©ussis</div>
            </div>
            <div class="stat-box failed">
                <div class="stat-number" id="failed-tests">0</div>
                <div class="stat-label">√âchou√©s</div>
            </div>
        </div>
    </div>

    <script>
        // Simulation du syst√®me de mise de la machine √† sous
        const MIN_BET = 1.00;
        const MAX_BET = 25.00;
        const BET_STEP = 1.00;
        const DEFAULT_BET = 5.00;
        
        class BetManager {
            constructor(initialBalance = 100.00) {
                this.currentBet = DEFAULT_BET;
                this.userBalance = initialBalance;
            }
            
            updateBet(newBet) {
                if (newBet < MIN_BET) {
                    newBet = MIN_BET;
                } else if (newBet > MAX_BET) {
                    newBet = MAX_BET;
                }
                this.currentBet = newBet;
                return this.currentBet;
            }
            
            increaseBet() {
                return this.updateBet(this.currentBet + BET_STEP);
            }
            
            decreaseBet() {
                return this.updateBet(this.currentBet - BET_STEP);
            }
            
            canPlaceBet() {
                return this.userBalance >= this.currentBet;
            }
            
            placeBet() {
                if (!this.canPlaceBet()) {
                    throw new Error("Solde insuffisant");
                }
                this.userBalance -= this.currentBet;
                return this.currentBet;
            }
            
            addWinnings(amount) {
                this.userBalance += amount;
            }
        }

        // Framework de tests
        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
            }
            
            addTest(name, testFn) {
                this.tests.push({ name, testFn });
            }
            
            assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }
            
            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(`${message}\n  Attendu: ${expected}\n  Obtenu: ${actual}`);
                }
            }
            
            async runAll() {
                this.results = [];
                const resultsContainer = document.getElementById('test-results');
                resultsContainer.innerHTML = '';
                
                for (const test of this.tests) {
                    const result = await this.runTest(test);
                    this.results.push(result);
                    this.displayTestResult(result);
                }
                
                this.displaySummary();
            }
            
            async runTest(test) {
                const result = {
                    name: test.name,
                    passed: false,
                    steps: [],
                    error: null
                };
                
                try {
                    await test.testFn(this, result);
                    result.passed = true;
                } catch (error) {
                    result.passed = false;
                    result.error = error.message;
                }
                
                return result;
            }
            
            displayTestResult(result) {
                const container = document.getElementById('test-results');
                
                const testDiv = document.createElement('div');
                testDiv.className = 'test-container';
                
                const header = document.createElement('div');
                header.className = 'test-header';
                
                const name = document.createElement('div');
                name.className = 'test-name';
                name.textContent = result.name;
                
                const status = document.createElement('div');
                status.className = `test-status ${result.passed ? 'passed' : 'failed'}`;
                status.textContent = result.passed ? '‚úì R√âUSSI' : '‚úó √âCHOU√â';
                
                header.appendChild(name);
                header.appendChild(status);
                testDiv.appendChild(header);
                
                const details = document.createElement('div');
                details.className = 'test-details';
                
                result.steps.forEach(step => {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = `test-step ${step.success ? 'success' : 'error'}`;
                    stepDiv.textContent = step.message;
                    details.appendChild(stepDiv);
                });
                
                if (result.error) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'test-step error';
                    errorDiv.textContent = `‚ùå Erreur: ${result.error}`;
                    details.appendChild(errorDiv);
                }
                
                testDiv.appendChild(details);
                container.appendChild(testDiv);
            }
            
            displaySummary() {
                const total = this.results.length;
                const passed = this.results.filter(r => r.passed).length;
                const failed = total - passed;
                
                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;
            }
        }

        // D√©finition des tests
        const runner = new TestRunner();

        runner.addTest("Test 1: Initialisation de la mise par d√©faut", (assert, result) => {
            result.steps.push({ success: true, message: "Cr√©ation d'un nouveau BetManager..." });
            const manager = new BetManager();
            
            result.steps.push({ success: true, message: `V√©rification: currentBet = ${manager.currentBet}` });
            assert.assertEqual(manager.currentBet, DEFAULT_BET, "La mise initiale devrait √™tre 5.00");
            
            result.steps.push({ success: true, message: "‚úì La mise par d√©faut est correctement initialis√©e √† 5.00 ‚Ç¨" });
        });

        runner.addTest("Test 2: Augmentation de la mise", (assert, result) => {
            const manager = new BetManager();
            result.steps.push({ success: true, message: `Mise initiale: ${manager.currentBet} ‚Ç¨` });
            
            manager.increaseBet();
            result.steps.push({ success: true, message: `Apr√®s increaseBet(): ${manager.currentBet} ‚Ç¨` });
            assert.assertEqual(manager.currentBet, 6.00, "La mise devrait √™tre 6.00");
            
            manager.increaseBet();
            result.steps.push({ success: true, message: `Apr√®s 2√®me increaseBet(): ${manager.currentBet} ‚Ç¨` });
            assert.assertEqual(manager.currentBet, 7.00, "La mise devrait √™tre 7.00");
            
            result.steps.push({ success: true, message: "‚úì L'augmentation de la mise fonctionne correctement" });
        });

        runner.addTest("Test 3: Diminution de la mise", (assert, result) => {
            const manager = new BetManager();
            manager.updateBet(10.00);
            result.steps.push({ success: true, message: `Mise initiale: ${manager.currentBet} ‚Ç¨` });
            
            manager.decreaseBet();
            result.steps.push({ success: true, message: `Apr√®s decreaseBet(): ${manager.currentBet} ‚Ç¨` });
            assert.assertEqual(manager.currentBet, 9.00, "La mise devrait √™tre 9.00");
            
            result.steps.push({ success: true, message: "‚úì La diminution de la mise fonctionne correctement" });
        });

        runner.addTest("Test 4: Limite minimale de mise", (assert, result) => {
            const manager = new BetManager();
            manager.updateBet(2.00);
            result.steps.push({ success: true, message: `Mise initiale: ${manager.currentBet} ‚Ç¨` });
            
            manager.decreaseBet();
            result.steps.push({ success: true, message: `Apr√®s decreaseBet(): ${manager.currentBet} ‚Ç¨` });
            assert.assertEqual(manager.currentBet, 1.00, "La mise devrait √™tre 1.00");
            
            manager.decreaseBet();
            result.steps.push({ success: true, message: `Apr√®s tentative de descendre sous MIN: ${manager.currentBet} ‚Ç¨` });
            assert.assertEqual(manager.currentBet, 1.00, "La mise ne devrait pas descendre sous 1.00");
            
            result.steps.push({ success: true, message: "‚úì La limite minimale (1.00 ‚Ç¨) est respect√©e" });
        });

        runner.addTest("Test 5: Limite maximale de mise", (assert, result) => {
            const manager = new BetManager();
            manager.updateBet(24.00);
            result.steps.push({ success: true, message: `Mise initiale: ${manager.currentBet} ‚Ç¨` });
            
            manager.increaseBet();
            result.steps.push({ success: true, message: `Apr√®s increaseBet(): ${manager.currentBet} ‚Ç¨` });
            assert.assertEqual(manager.currentBet, 25.00, "La mise devrait √™tre 25.00");
            
            manager.increaseBet();
            result.steps.push({ success: true, message: `Apr√®s tentative de d√©passer MAX: ${manager.currentBet} ‚Ç¨` });
            assert.assertEqual(manager.currentBet, 25.00, "La mise ne devrait pas d√©passer 25.00");
            
            result.steps.push({ success: true, message: "‚úì La limite maximale (25.00 ‚Ç¨) est respect√©e" });
        });

        runner.addTest("Test 6: Placement de mise avec solde suffisant", (assert, result) => {
            const manager = new BetManager(100.00);
            manager.updateBet(10.00);
            result.steps.push({ success: true, message: `Solde initial: ${manager.userBalance} ‚Ç¨, Mise: ${manager.currentBet} ‚Ç¨` });
            
            assert.assert(manager.canPlaceBet(), "Devrait pouvoir placer la mise");
            result.steps.push({ success: true, message: "‚úì canPlaceBet() retourne true" });
            
            const betAmount = manager.placeBet();
            result.steps.push({ success: true, message: `Mise plac√©e: ${betAmount} ‚Ç¨, Nouveau solde: ${manager.userBalance} ‚Ç¨` });
            assert.assertEqual(manager.userBalance, 90.00, "Le solde devrait √™tre 90.00");
            
            result.steps.push({ success: true, message: "‚úì Le solde est correctement d√©duit" });
        });

        runner.addTest("Test 7: Placement de mise avec solde insuffisant", (assert, result) => {
            const manager = new BetManager(3.00);
            manager.updateBet(5.00);
            result.steps.push({ success: true, message: `Solde initial: ${manager.userBalance} ‚Ç¨, Mise: ${manager.currentBet} ‚Ç¨` });
            
            assert.assert(!manager.canPlaceBet(), "Ne devrait pas pouvoir placer la mise");
            result.steps.push({ success: true, message: "‚úì canPlaceBet() retourne false" });
            
            let errorThrown = false;
            try {
                manager.placeBet();
            } catch (error) {
                errorThrown = true;
                result.steps.push({ success: true, message: `‚úì Exception lev√©e: "${error.message}"` });
            }
            
            assert.assert(errorThrown, "Une exception devrait √™tre lev√©e");
            result.steps.push({ success: true, message: "‚úì La mise est refus√©e avec solde insuffisant" });
        });

        runner.addTest("Test 8: Ajout de gains", (assert, result) => {
            const manager = new BetManager(50.00);
            result.steps.push({ success: true, message: `Solde initial: ${manager.userBalance} ‚Ç¨` });
            
            manager.addWinnings(100.00);
            result.steps.push({ success: true, message: `Apr√®s addWinnings(100.00): ${manager.userBalance} ‚Ç¨` });
            assert.assertEqual(manager.userBalance, 150.00, "Le solde devrait √™tre 150.00");
            
            result.steps.push({ success: true, message: "‚úì Les gains sont correctement ajout√©s au solde" });
        });

        runner.addTest("Test 9: Calcul de gains proportionnels", (assert, result) => {
            const manager = new BetManager(100.00);
            
            // Test avec diff√©rentes mises
            const testCases = [
                { bet: 1.00, multiplier: 10, expectedWin: 10.00 },
                { bet: 5.00, multiplier: 20, expectedWin: 100.00 },
                { bet: 25.00, multiplier: 500, expectedWin: 12500.00 }
            ];
            
            testCases.forEach(test => {
                const calculatedWin = test.bet * test.multiplier;
                result.steps.push({ 
                    success: true, 
                    message: `Mise: ${test.bet} ‚Ç¨ √ó ${test.multiplier} = ${calculatedWin} ‚Ç¨ (attendu: ${test.expectedWin} ‚Ç¨)` 
                });
                assert.assertEqual(calculatedWin, test.expectedWin, `Les gains devraient √™tre ${test.expectedWin}`);
            });
            
            result.steps.push({ success: true, message: "‚úì Les calculs de gains proportionnels sont corrects" });
        });

        runner.addTest("Test 10: Sc√©nario complet de jeu", (assert, result) => {
            const manager = new BetManager(100.00);
            result.steps.push({ success: true, message: `üéÆ D√©but du jeu - Solde: ${manager.userBalance} ‚Ç¨` });
            
            // Tour 1: Mise de 5‚Ç¨, perd
            manager.updateBet(5.00);
            manager.placeBet();
            result.steps.push({ success: true, message: `Tour 1: Mise ${manager.currentBet + 5} ‚Ç¨ (perdu), Solde: ${manager.userBalance} ‚Ç¨` });
            assert.assertEqual(manager.userBalance, 95.00, "Le solde devrait √™tre 95.00");
            
            // Tour 2: Mise de 10‚Ç¨, gagne 50‚Ç¨
            manager.updateBet(10.00);
            manager.placeBet();
            manager.addWinnings(50.00);
            result.steps.push({ success: true, message: `Tour 2: Mise ${manager.currentBet + 10} ‚Ç¨, Gain 50 ‚Ç¨, Solde: ${manager.userBalance} ‚Ç¨` });
            assert.assertEqual(manager.userBalance, 135.00, "Le solde devrait √™tre 135.00");
            
            // Tour 3: Mise de 25‚Ç¨, gagne 500‚Ç¨
            manager.updateBet(25.00);
            manager.placeBet();
            manager.addWinnings(500.00);
            result.steps.push({ success: true, message: `Tour 3: Mise ${manager.currentBet + 25} ‚Ç¨, Gain 500 ‚Ç¨, Solde: ${manager.userBalance} ‚Ç¨` });
            assert.assertEqual(manager.userBalance, 610.00, "Le solde devrait √™tre 610.00");
            
            result.steps.push({ success: true, message: "‚úì Le sc√©nario complet de jeu fonctionne correctement" });
        });

        async function runAllTests() {
            const button = document.querySelector('.run-button');
            button.disabled = true;
            button.textContent = '‚è≥ Tests en cours...';
            
            await runner.runAll();
            
            button.disabled = false;
            button.textContent = '‚ñ∂Ô∏è Relancer tous les tests';
        }

        // Auto-run au chargement
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 500);
        });
    </script>
</body>
</html>
